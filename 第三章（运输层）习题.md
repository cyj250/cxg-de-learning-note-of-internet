# 第三章（运输层）习题

**P1**

|        | source port numbers | destination port numbers |
| ------ | ------------------- | ------------------------ |
| a) A→S | 467                 | 23                       |
| b) B→S | 513                 | 23                       |
| c) S→A | 23                  | 467                      |
| d) S→B | 23                  | 513                      |

e.可能相同

f.不会相同

**P2**

假设A、B、C三台主机的地址分别为a、b、c

| 主机名  | 源端口号 | 源IP地址 | 目标端口号 | 目标IP地址 |
| :-----: | :------: | :------: | :--------: | :--------: |
|    A    |    80    |    b     |   26145    |     a      |
| C左进程 |    80    |    b     |    7532    |     c      |
| C右进程 |    80    |    b     |   26415    |     c      |

**P3**

  为了检测错误，接收方添加四个单词（三个原始单词和校验和）。如果和包含一个零，接收器知道有一个错误。所有的一位错误都会被检测到，但是两位错误可以不被检测到（例如，如果第一个单词的最后一个数字被转换为0，第二个单词的最后一个数字被转换为1）。

**P4**

a. 0 0 1 1 1 1 1 0

b. 1 0 1 1 1 1 1 1

c.第一个字节=01010100；第二个字节=01101101。

**P5**

不，接收方不能完全确定没有发生任何位错误。这是因为计算数据包的校验和的方式。如果包中两个16位字的对应位（相加在一起）是0和1，那么即使这些位分别翻转到1和0，和仍然保持不变。因此，接收方计算的1s补码也将是相同的。这意味着，即使存在传输错误，校验和也将进行验证。

**P6**



<img src="C:\Users\cyj250\AppData\Roaming\Typora\typora-user-images\image-20210309162230751.png" alt="image-20210309162230751" style="zoom: 25%;" /><img src="C:\Users\cyj250\AppData\Roaming\Typora\typora-user-images\image-20210309162412486.png" alt="image-20210309162412486" style="zoom:25%;" />

假设发送方处于“从上面等待呼叫1”状态，而接收方（作业问题中显示的接收方）处于“从下面等待1”状态。发送方发送一个序列号为1的数据包，并转换为“等待ACK或NAK 1”，等待ACK或NAK。现在假设接收方正确地接收序列号为1的数据包，发送一个ACK，然后转换为状态“从下面等待0”，等待序列号为0的数据包。但是，ACK已损坏。当rdt2.1发送方获得损坏的ACK时，它用序列号1重新发送数据包。然而，接收方正在等待序列号为0的数据包，并且（如家务问题所示）总是在没有得到序列号为0的数据包时发送NAK。因此，发送方将始终发送一个序列号为1的数据包，而接收方将始终锁定该数据包。也不会从那个状态前进。

**P7**

要想最好地回答这个问题，首先考虑一下为什么我们需要序列号。我们看到发送方需要序列号，以便接收方能够判断数据包是否是已经接收到的数据包的副本。在ACK的情况下，发送方不需要这个信息（即ACK上的序列号）来判断是否检测到重复的ACK。对于rdt3.0接收器来说，一个重复的ACK是显而易见的，因为当它接收到原始ACK时，它会转换到下一个状态。重复的ACK不是发送方需要的ACK，因此被rdt3.0发送方忽略。

**P8**

协议rdt3.0的发送方与协议2.2的发送方不同，因为已经添加了超时。我们已经看到，超时的引入增加了在发送方到接收方数据流中重复数据包的可能性。然而，协议rdt2.2中的接收方已经可以处理重复的数据包。(如果接收方发送丢失的ACK，然后发送方重新传输旧数据，则RDT2.2中的接收方重复出现)。因此，协议rdt2.2中的接收器也将作为协议rdt3.0中的接收器工作。

**P9**

<img src="C:\Users\cyj250\AppData\Roaming\Typora\typora-user-images\image-20210309164106403.png" alt="image-20210309164106403" style="zoom:25%;" />

**P10**

在这里，我们添加一个计时器，它的值大于已知的往返传播延迟。我们将超时事件添加到“等待ACK或NAK 0”和“等待ACK或NAK 1”状态。如果发生超时事件，则重新发送最近发送的数据包。让我们看看为什么这个协议仍将与rdt2.1接收器一起工作。
\- 假设超时是由丢失的数据包引起的，即发送方到接收方通道上的数据包。在这种情况下，接收机从未接收到先前的传输，并且从接收机的角度来看，如果接收到超时重传，它看起来与接收到的原始传输完全相同。
\- 假设现在一个ACK丢失了。接收器最终会在超时时重新发送数据包。但是，重传与ACK被混淆时的动作完全相同。因此，发送者的反应与损失是一样的，就像混乱的ACK一样。RDT2.1接收器已经可以处理混淆的ACK的情况。

**P11**

如果删除了该消息的发送，发送和接收侧将死锁，等待永远不会发生的事件。以下是一种场景：
\- sender发送pkt0，输入“等待ACK0状态”，等待数据包返回来自接收机
\- 接收器处于“从下面等待0”状态，接收到损坏的数据包来自发送方。假设它不发送任何信息，只需重新输入“等待0”处于“下”状态。

现在，ender正在等待来自接收机的某种类型的ACK，并且接收机等待数据包形成发送方-死锁！也就是说发送方收不到ACK信息，不会重传，也没有定时器。

**P12**

该协议仍在工作，因为如果重新传输将是如果接收到错误的分组实际上已经丢失（并且从接收机的观点来看，它从不知道这些事件中的哪一个发生，如果有的话）。

为了解决这个问题背后的更微妙的问题，一个必须允许过早的发生超时。在这种情况下，如果分组的每个额外副本被确认并且每个副本接收的额外ACK导致要发送的当前分组的另一个额外拷贝，发送分组N的次数将随着N接近无穷大而不受限制地增加。

**P13**

![图12](https://image.feater.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B12.png?imageView2/0/q/75|watermark/2/text/aHR0cHM6Ly9mZWF0ZXIudG9w/font/5a6L5L2T/fontsize/800/fill/I0VFMUIxQg==/dissolve/100/gravity/SouthWest/dx/10/dy/10)

**P14**

在仅NAK协议中，只有当接收到分组x+1时，接收方才检测丢包x。也就是说，接收器接收x-1，然后x+1，只有当接收到x+1时，接收器才会意识到x被忽略了。如果x的传输和x+1的传输之间存在很长的延迟，那么在只使用NAK协议下，需要很长时间才能恢复x。

另一方面，如果数据经常被发送，那么以NAK为唯一方案的恢复可能会很快发生。此外，如果错误很少发生，那么Naks只是偶尔被发送（当需要时），并且ACK永远不会被发送-NAK中的反馈大大减少-仅在ACK的情况下才发送。

**P15**

发送数据包需要12微妙，0.012ms/pkt，0.012*n/30.012=0.9，得n约为2251.

**P16**

是。这实际上会导致发送方向通道发送大量流水线数据。

是。这里有一个潜在的问题。如果数据段丢失在通道中，那么RDT3.0的发送方将不会重新发送这些段，除非应用程序中有一些从丢失中恢复的额外机制。

**P17**

![image-20210310144659100](C:\Users\cyj250\AppData\Roaming\Typora\typora-user-images\image-20210310144659100.png)

**P18**

在我们的解决方案中，发送方将等待接收到一对消息(seqnum和seqnum+1)的ACK，然后再转到下一对消息。数据包有一个数据字段，并携带两位序列号.也就是说，有效序列号为0、1、2和3。(注意：您应该考虑为什么1位序列号空间0，1在下面的解决方案中不能工作。)ACK消息携带他们正在确认的数据包的序列号。

发送方和接收方的FSM如图2所示。请注意，发送方状态记录：(i)当前对未收到ACK，(ii)接收到用于seqnum(仅)的ACK，或接收到用于seqnum 1的ACK(仅)。在这个图中，我们假设seqnum最初为0，并且发送者已经发送了第一个两个数据消息（获取要进行的事情）。发送方和接收方的时间线跟踪从丢失的数据包中恢复如下所示：

![图14](https://image.feater.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B14.png?imageView2/0/q/75|watermark/2/text/aHR0cHM6Ly9mZWF0ZXIudG9w/font/5a6L5L2T/fontsize/800/fill/I0VFMUIxQg==/dissolve/100/gravity/SouthWest/dx/10/dy/10)

![图15](https://image.feater.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B15.png?imageView2/0/q/75|watermark/2/text/aHR0cHM6Ly9mZWF0ZXIudG9w/font/5a6L5L2T/fontsize/800/fill/I0VFMUIxQg==/dissolve/100/gravity/SouthWest/dx/10/dy/10)

图2：问题的发送方和接收方(3.18)



| Sender          | Receiver           |
| --------------- | ------------------ |
| make pair (0,1) |                    |
| send packet 0   |                    |
| Packet 0 drops  |                    |
| send packet 1   |                    |
|                 | receive packet 1   |
|                 | buffer packet 1    |
|                 | send ACK 1         |
| receive ACK 1   |                    |
| (timeout)       |                    |
| resend packet 0 |                    |
|                 | receive packet 0   |
|                 | deliver pair (0,1) |
|                 | send ACK 0         |
| receive ACK 0   |                    |

**P19**

这个问题是简单停止和等待协议(rdt3.0)上的一个变化。由于信道可能丢失消息，并且由于发送方可能重新发送其中一个接收方已经接收到的消息（要么由于过早超时，要么由于另一个接收方尚未正确接收数据），因此需要序列号。在rdt3.0中，0位序列号在这里就足够了。

发送方和接收方FSM如图3所示。在此问题中，发送方状态指示发送方是否从B（仅）、从C（仅）或从非C或B接收到ACK。接收方状态指示接收方正在等待哪个序列号。

![图16](https://image.feater.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B16.png?imageView2/0/q/75|watermark/2/text/aHR0cHM6Ly9mZWF0ZXIudG9w/font/5a6L5L2T/fontsize/800/fill/I0VFMUIxQg==/dissolve/100/gravity/SouthWest/dx/10/dy/10)

![图17](https://image.feater.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B17.png?imageView2/0/q/75|watermark/2/text/aHR0cHM6Ly9mZWF0ZXIudG9w/font/5a6L5L2T/fontsize/800/fill/I0VFMUIxQg==/dissolve/100/gravity/SouthWest/dx/10/dy/10)

**P20**

![图18](https://image.feater.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B18.png?imageView2/0/q/75|watermark/2/text/aHR0cHM6Ly9mZWF0ZXIudG9w/font/5a6L5L2T/fontsize/800/fill/I0VFMUIxQg==/dissolve/100/gravity/SouthWest/dx/10/dy/10)